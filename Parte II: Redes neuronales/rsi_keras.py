# -*- coding: utf-8 -*-
"""RSI_keras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yPVJ-WT9OQLPS8b3E8wmJU9Wky7rOvsc
"""


# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard

# Commented out IPython magic to ensure Python compatibility.
import tensorflow.keras as kr
import tensorflow as tf
# %tensorflow_version
import numpy as np
import matplotlib.pyplot as plt
import ta
import pandas as pd
import pandas_datareader.data as web
import datetime as dt
from tensorflow.python import debug as tf_debug

rsi_df = pd.read_excel('rsi.xlsx')
output_df = pd.read_excel('output.xlsx')
rsi_test_df = pd.read_excel('rsi_test.xlsx')
rsi_val_df = pd.read_excel('rsi_val.xlsx')
output_val_df = pd.read_excel('output_val.xlsx')

matriz_rsi = np.transpose(rsi_df.to_numpy())
matriz_output = output_df.to_numpy()
matriz_rsi_test = np.transpose(rsi_test_df.to_numpy())
matriz_rsi_val = np.transpose(rsi_val_df.to_numpy())
matriz_output_val = output_val_df.to_numpy()

rsi_data = matriz_rsi[:,:20]
output_data = matriz_output[19:,:]
rsi_test = matriz_rsi_test[:,:20]
rsi_val = matriz_rsi_val[:,:20]
output_val = matriz_output_val[19:,:]

for i in range(matriz_rsi.shape[1]-20):
    rsi_data = np.concatenate((rsi_data,matriz_rsi[:,(i+1):(i+21)]))

for j in range(matriz_rsi_test.shape[1]-20):
    rsi_test = np.concatenate((rsi_test,matriz_rsi_test[:,(j+1):(j+21)]))

for l in range(matriz_rsi_val.shape[1]-20):
    rsi_val = np.concatenate((rsi_val,matriz_rsi_val[:,(l+1):(l+21)]))

# Datos de entrenamiento
X = rsi_data
Y = output_data

# Datos de validación
X_val = rsi_val
Y_val = output_val

# Datos de prueba
X_test = rsi_test

lr = 0.05
nn = [1, 200, 1]

# Creamos el objeto que contendrá a nuestra red neuronal, como
# secuencia de capas.
model = kr.Sequential()

# Añadimos la capa 1
l1 = model.add(kr.layers.Dense(nn[1], activation='relu'))

# Añadimos la capa 3
l3 = model.add(kr.layers.Dense(nn[2], activation='sigmoid'))

# Compilamos el modelo, definiendo la función de coste y el optimizador.
model.compile(loss='mse', optimizer=kr.optimizers.SGD(lr=lr), metrics=['acc'])

# Y entrenamos al modelo.
history = model.fit(X, Y, batch_size=32, epochs=100, validation_data=(X_val,Y_val),callbacks=[tensorboard_callback])

# Gráficos
loss_train = history.history['loss']
epoch_count = range(1, len(loss_train) + 1)
plt.plot(epoch_count, loss_train, 'g', label='Training loss')
plt.title('Training loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

loss_train = history.history['acc']
epoch_count = range(1, len(loss_train) + 1)
plt.plot(epoch_count, loss_train, 'g', label='Training accuracy')
plt.title('Training accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

predicciones = model.predict(X_test)
print(predicciones)
puntos_compra = predicciones #where...

